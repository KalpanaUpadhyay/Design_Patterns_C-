Singleton Pattern
ðŸ”¹ Purpose:
Ensure a class has only one instance and provide a global access point to it.

ðŸ’¡ Real-World Examples:
Logger (only one logging instance needed)

Database Connection Manager

Configuration Manager

Printer Spooler

ðŸ”¸ Basic Implementation (C++ - Not Thread-Safe)

class Singleton {
private:
    static Singleton* instance;
    Singleton() {}  // private constructor

public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    void showMessage() {
        std::cout << "Hello from Singleton!" << std::endl;
    }
};

Singleton* Singleton::instance = nullptr;
ðŸ” Thread-Safe Singleton in Modern C++ (C++11 onwards)

class Singleton {
private:
    Singleton() {}  // private constructor

public:
    // Deleted to avoid copies
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton& getInstance() {
        static Singleton instance;  // thread-safe in C++11 and above
        return instance;
    }

    void showMessage() {
        std::cout << "Thread-safe Singleton!" << std::endl;
    }
};
â— Common Interview Pitfalls:
Multiple threads accessing getInstance() â€“ race conditions

Copy constructors breaking the singleton

Global variables vs controlled access

ðŸŽ¯ Interview Question Example:
â€œDesign a Logger class that ensures only one instance exists and is shared across the system.â€
