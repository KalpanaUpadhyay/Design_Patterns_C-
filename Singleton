Singleton Pattern

🔹 Purpose:
Ensure a class has only one instance and provide a global access point to it.

💡 Real-World Examples:
Logger (only one logging instance needed)

Database Connection Manager

Configuration Manager

Printer Spooler

🔸 Basic Implementation (C++ - Not Thread-Safe)

class Singleton {
private:
    static Singleton* instance;
    Singleton() {}  // private constructor

public:
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    void showMessage() {
        std::cout << "Hello from Singleton!" << std::endl;
    }
};

Singleton* Singleton::instance = nullptr;

🔐 Thread-Safe Singleton in Modern C++ (C++11 onwards)
class Singleton {
private:
    Singleton() {}  // private constructor

public:
    // Deleted to avoid copies
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton& getInstance() {
        static Singleton instance;  // thread-safe in C++11 and above
        return instance;
    }

    void showMessage() {
        std::cout << "Thread-safe Singleton!" << std::endl;
    }
};

❗ Common Interview Pitfalls:
Multiple threads accessing getInstance() – race conditions

Copy constructors breaking the singleton

Global variables vs controlled access

🎯 Interview Question Example:
“Design a Logger class that ensures only one instance exists and is shared across the system.”


📡 LTE / Telecom Example: ConfigManager Singleton

Imagine your LTE eNodeB has global system-wide configuration values (bandwidth, carrier frequency, scheduling timers, etc.).

Singleton Usage:

class ConfigManager {
private:
    static ConfigManager* instance;
    ConfigManager() {
        // Load .cfg file, initialize parameters
    }

public:
    static ConfigManager* getInstance() {
        if (!instance)
            instance = new ConfigManager();
        return instance;
    }

    int getBandwidth() { return bandwidth; }
    std::string getSchedulerType() { return scheduler; }

private:
    int bandwidth;
    std::string scheduler;
};
Then in your MAC or PHY code:

int bw = ConfigManager::getInstance()->getBandwidth();
This ensures:

Only one config object exists

All layers use consistent values

🔥 Interview Tips

✅ When to use Singleton:

Global shared state

Central coordination

Resource that must not be duplicated (like loggers, config)

🚫 When not to use:

If class has to support multiple configurations

When you need testable, decoupled design (Singletons are hard to mock)
