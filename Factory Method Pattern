ğŸ§± Next Pattern: Factory Method Pattern
âœ… Why itâ€™s important:
Real-world use: Creating objects without hardcoding class names

Common in frameworks, SDKs, plugin systems, etc.

Highly asked in C++ system design interviews (including Adobe, Microsoft)

ğŸ” What Youâ€™ll Learn:
ğŸ”§ Concept:
Define an interface for creating an object, but let subclasses decide which class to instantiate.

ğŸ§  Key Learning:
Avoids new scattered across code

Promotes loose coupling

Cleanly supports extension without changing existing code

ğŸ‘©â€ğŸ’» Example Use Case:
Imagine you want to create different types of Transport objects:

Car, Bike, Bus

Using a Factory, you can do:
Transport* t = TransportFactory::create("car");
And it will return a Car object â€” no if-else, no new Car() all over your code.

âœ… Real-Life Analogy
Imagine an app where users select a vehicle type: "car", "bike", or "bus".
Instead of doing:
if (type == "car") transport = new Car();
else if (type == "bike") transport = new Bike();
You just do:
Transport* t = TransportFactory::create("car");
This gives you:

Cleaner code

Easier maintenance

Flexibility to add more types (Truck, Scooter, etc.) without changing core logic

ğŸ§± Code Walkthrough (C++)
ğŸ”¹ Step 1: Define a Common Base Class
class Transport {
public:
    virtual void deliver() = 0;
    virtual ~Transport() = default;
};
ğŸ”¹ Step 2: Create Derived Classes
class Car : public Transport {
public:
    void deliver() override {
        std::cout << "Delivering by Car ğŸš—\n";
    }
};

class Bike : public Transport {
public:
    void deliver() override {
        std::cout << "Delivering by Bike ğŸï¸\n";
    }
};

class Bus : public Transport {
public:
    void deliver() override {
        std::cout << "Delivering by Bus ğŸšŒ\n";
    }
};
ğŸ”¹ Step 3: Factory Class
class TransportFactory {
public:
    static Transport* create(const std::string& type) {
        if (type == "car")  return new Car();
        if (type == "bike") return new Bike();
        if (type == "bus")  return new Bus();
        return nullptr;
    }
};
ğŸ§ª Usage in main()
int main() {
    std::string input;
    std::cout << "Enter transport type (car/bike/bus): ";
    std::cin >> input;

    Transport* transport = TransportFactory::create(input);
    if (transport) {
        transport->deliver();
        delete transport;
    } else {
        std::cout << "Invalid transport type\n";
    }

    return 0;
}

âœ… Benefits
| ğŸ” Feature                 | ğŸ‘ Benefit                   |
| -------------------------- | ---------------------------- |
| Centralized creation logic | Cleaner code                 |
| Avoids `new` everywhere    | Easier to maintain           |
| Easily extendable          | Add `Truck`, `Scooter`, etc. |

ğŸ’¬ Interview Tips
Common question: â€œHow would you avoid tight coupling when creating objects?â€

Use Factory Pattern when:

You need many subclasses of one base type

Creation logic may change

You want to decouple object creation from usage

